Let capacity = max allowed weight

Let K = (n+1)x(W+1) table initialized with all zeroes

loop, int i from 0 to n+1:
    loop, int w from 0 to w+1:
        if i == 0 or w == 0:                                                                 
            K[i][w] = 0                                                                    
        elif items[i-1].wt <= w:                                                           
            K[i][w] = max(items[i-1].val + K[i-1][w-items[i-1].wt],  K[i-1][w])            
        else:                                                                              
            K[i][w] = K[i-1][w]  

value1 = K[n][W]

Let S = set of all items used already 
Let capacityUsed = weight used in previous algorithm

if capacityUsed < capacity:
    Let unused = a set of all 'f' items that have not been used already
    sort unused by value of each item (cost / weight)

    Let totalValue = 0
    Let newMaxW = capacity - capacityUsed

    loop, int i in unused: 
            if newMaxW - i[0] >= 0: 
                newMaxW -= i[0]
                totalValue += i[1]
            else: 
                Let fraction = newMaxW / i[0] 
                totalValue += i[1] * fraction 
                break

    value1 += totalValue
 

    Let value2 = 0
    Let items = a list of item objects will weights and cost and type ('f' or 'w')
    sort items by value of each item (cost / weight) greatest to least
    sort items by type (this takes care of the scenario where there are much more 'f' items then 'w' items)


    loop, i in items: 
        if W - i.wt >= 0: 
            W -= i.wt
            value2 += i.val
        else: 
            if i.type == 'w': # skip if item is 'w'
                continue
            fraction = W / i.wt 
            value2 += i.val * fraction 


    let maxValue = max(value1, value2)

    print('max value is: ', maxValue)